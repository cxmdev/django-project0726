''Para setar um local estatico para minhas imagens dentro da pagina de admin, devo adicionar (concatenar) na url do projeto o seguinte caminho: urlpatterns += static(settings.MEDIA_URL, document_root = settings.MEDIA_ROOT), acompanhado das alteracoes no arquivo settings.py 
MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"
Django shell eh um django interativo do proprio python, que serve para testar, iterar os codigos do app, que pode ser executado atraves do comando python .\manage.py shell
o comando ._meta.get_fields() pega todos os campos presentes no meu orm.
para salvar alteracoes no orm, deve-se semrpe lembrar de usar o comando save()
o filter retorna um queryset
Para criar usuarios atraves do shell devemos executar os seguintes comandos: from django.contrib.auth.models import User, User.objects.create_user(first_name='Maria', last_name='Helena', username='MariaHelena', email='mhelena@gmail.com', password='123456') 
sempre priorizar manter a logica no codigo python do que nos tempaltes
para rodar testes eh necessario instalar pip install pytest e pytest-django
para imprimir testes via linha de comando com mensagens no pytest o comando deve ser pytest -rP
No caso de querer os comentarios dos testes no vscode basta adicionar -rP no arquivo pytest.ini addopts
para usar o runner do unittest ao inves do pytest eh somente digitar python manage.py test
para executar o pytest com o runner pytest basta digitar pytest
functional tests sao os teste realizados na pratica, como se fosse um usuario (ex: abrir o nevegador hardmode)
Em testes, devemos ser super descritivos, mesmo que fique com um nome grande, para facilitar o debug
para seu runner de test, no caso o pytest ficar ouvindo as modificacoes do codigo, e necessario instalar o pytest-watch e executar o comando ptw.
para adicionar argumentos em ordem, devemos usar o args com uma tupla arg =(1,), para adicionar um dicionario, devemos usar kwargs com um dicionario kwargs={'id': 1}
== checa se o valor corresponde a outro valor, o IS checa a identidade, a referencia de memoria, se um objeto e um objeto mesmo com nomes diferentes
quando referenciamos o valor de uma variavel com uma outra variavel, a segunda variavel tera a mesma identidade da variavel 1
com a finalidade de organizar melhor os testes temos que criar um arquivo tests dentro do app e dentro deste arquivo simular um __init__.py vazio, e criar o nome das nossas classes de teste para cada teste, isso evita que tenhamos todas as classes dentro de um unico arquivo no tests.py que vem como default do python
o comando python manage.py test -v3 permite que vejamos a execucao do unitest default do django em modo mais verboso, quando v representa a quantidade de verbosidade da execucao.
o django tem uma funcao chamada self.client que trabalha com os dados inseridos no django, como get por exemplo que captura dados especificos desejados, self.client.get(views.algo)
para executar um teste individualmente no pytest o comando e pytest -k 'nome_do_teste', no unittest basta adicionar -k na frente. Para utilizar o pytest watch, o comando e ptw -- -k 'nomedoteste'
quando eu crio uma variavel e atribuo a ela a criacao de um model sem chamar o gerenciador objects, essa variavel nao tera um id e nao sera salva nos meus models, para que seja criada e salva, comos se tivesse sendo feito o save(), devo executar, por exemplo, o seguinte comando category = Category.objects.create(name='category')